#!/usr/bin/env bash
#
# AUTHOR:   Andreas Betschart.
#           Adapting and further developing some code by Pat David from:
#           https://discuss.pixls.us/t/annotation-with-imagemagick-watermark-ish
# DATE:     07.08.2019.
# PROGRAM:  fotoprep
VERSION=1.1
# USAGE:    Start the program from the command line and add all the images you want to edit as arguments.
# PURPOSE:  Prepare photos for use on the Internet, tablets, phones, etc.
#           1. Convert and resize images (even XCF and RAW files).
#           2. Remove tags, add copyright tags.
#           3. Add a watermark or an annotation.
# REASON:   Digikam's batch tool can't convert XCF or RAW files. So you will have to do that separately anyway.
# FILES:    fotoprep, the watermark file and the logo(s) for the annotation.
#           "$CONFIG" will be created by running the fotoprep setup (fotoprep -s).

##############################################################################
# WARNING: ONLY TOUCH STUFF BELOW THIS POINT IF YOU KNOW WHAT YOU ARE DOING. #
##############################################################################

#---------------------------------------------------------------------------
# Variables
#---------------------------------------------------------------------------
PWD=$(pwd)
directory=fotoprep_
workingDirectory=$$
theDate=$(date +%Y:%m:%d)
theYear=${theDate:0:4}
config="fotoprep.cfg"
sharpeningAmount=1
sharpeningThreshold=0.065
colorRegex='^#(([0-9a-fA-F]{2}){3}|([0-9a-fA-F]){3})$'
rawFormats=(\
    '.nef' '.NEF' \
    '.raf' '.RAF' \
    '.arw' '.ARW' \
    '.orf' '.ORF' \
    '.dng' '.DNG' \
    '.crw' '.CRW' \
    '.cr2' '.CR2' \
    '.raw' '.RAW' \
    '.nrw' '.NRW' \
    '.pef' '.PEF' \
    '.srw' '.SRW' \
    '.iiq' '.IIQ' \
    '.3fr' '.3FR' \
    '.dcr' '.DCR' \
    '.fff' '.FFF' \
    '.kdc' '.KDC' \
    '.mef' '.MEF' \
    '.mos' '.MOS' \
    '.mrw' '.MRW' \
    '.rw2' '.RW2' \
    '.rwl' '.RWL' \
    '.rwz' '.RWZ' \
    '.sr2' '.SR2' \
    '.srf' '.SRF' \
    '.x3f' '.X3F' \
    )
# Padding for the menu
padding=$(printf '%0.1s' "."{1..60})
paddingLength=60

#---------------------------------------------------------------------------
# Define colors
#---------------------------------------------------------------------------
# Black        0;30     Dark Gray     1;30
# Red          0;31     Light Red     1;31
# Green        0;32     Light Green   1;32
# Brown/Orange 0;33     Yellow        1;33
# Blue         0;34     Light Blue    1;34
# Purple       0;35     Light Purple  1;35
# Cyan         0;36     Light Cyan    1;36
# Light Gray   0;37     White         1;37
# printf "Some %bcolored text%b here\n" "${red}" "${noColor}"

red='\033[0;31m'
cyan='\033[0;36m'
lightCyan='\033[1;36m'
orange='\033[0;33m'
green='\033[0;32m'
lightPurple='\033[1;35m'
yellow='\033[1;33m'
noColor='\033[0m'
darkGray='\033[1;30m'

#---------------------------------------------------------------------------
# Functions.
#---------------------------------------------------------------------------
spinner()
{
    tput civis
    while ps a | awk '{print $1}' | grep -q $! ; do
        for x in \| / - \\; do
            printf "%b\b$x \b" "${yellow}"
            sleep 0.1
        done
    done
    printf "%b\n" "${noColor}"
    tput cnorm
}

usage()
{
    printf " %bfotoprep Usage:%b\n" "${yellow}" "${noColor}"
    printf " fotoprep version: %b\n" "${VERSION}"
    printf " fotoprep -s          %b->%b Run the setup program to set and/or\n" "${lightCyan}" "${noColor}"
    printf "                         change options.\n"
    printf "                         %bYou should do this before the first use!%b\n" "${orange}" "${noColor}"
    printf " fotoprep filename(s) %b->%b Prepare photos for use on the Internet,\n" "${lightCyan}" "${noColor}"
    printf "                         tablets, phones, etc.\n"
    printf " fotoprep -v          %b->%b Show the version number of fotoprep.\n" "${lightCyan}" "${noColor}"
    printf " fotoprep -h          %b->%b Show this help.\n" "${lightCyan}" "${noColor}"
    printf "\n"
    printf " The images you pass to fotoprep can be of different types,\n"
    printf " even GIMP and RAW files (using RawTherapee and its .pp3\n"
    printf " sidecar files). The files can come from several different\n"
    printf " directories in your file system at the same time.\n"
    printf " Don't worry, your images will not be changed.\n"
    printf " All operations are performed on copies of the files.\n"
    printf " The results will be placed in a new directory called:\n"
    printf " fotoprep-<PID> inside the directory where fotoprep was started.\n"
    exit 0
}

#---------------------------------------------------------------------------
# Check if the necessary programs are installed.
#---------------------------------------------------------------------------
command -v convert >/dev/null 2>&1 || { echo >&2 " It seems ImageMagick is not installed, please install it in order to proceed."; exit 1;}
command -v gimp >/dev/null 2>&1 || { echo >&2 " It seems GIMP is not installed, please install it in order to proceed."; exit 1;}
command -v exiftool >/dev/null 2>&1 || { echo >&2 " It seems Exiftool is not installed, please install it in order to proceed."; exit 1;}
command -v rawtherapee >/dev/null 2>&1 || { echo >&2 " It seems RawTherapee is not installed, please install it in order to proceed."; exit 1;}

#---------------------------------------------------------------------------
# Were any parameters given?
#---------------------------------------------------------------------------
if [[ $# -eq 0 ]] || [[ $* == "-h" ]]; then
    usage
fi

# Print the version of fotoprep
if [[ $* == "-v" ]]; then echo " fotoprep version: $VERSION" && exit 0 ; fi

#---------------------------------------------------------------------------
# Find out where the configuration file is.
#---------------------------------------------------------------------------
mySource="${BASH_SOURCE[0]}"
while [[ -h "$mySource" ]]; do # resolve $mySource until the file is no longer a symlink.
    myPath="$( cd -P "$( dirname "$mySource" )" && pwd )"
    mySource="$(readlink "$mySource")"
    [[ $mySource != /* ]] && mySource="$myPath/$mySource" # if $mySource was a relative symlink, we need to resolve it relative to the path where the symlink file was located.
done
myPath="$( cd -P "$( dirname "$mySource" )" && pwd )"

#---------------------------------------------------------------------------
# Run the setup?
#---------------------------------------------------------------------------
if [[ $* == "-s" ]]; then
    # Some sensible default values
    default_landscape=0.20
    default_portrait=0.35
    default_position=southeast
    default_horizontalOffset=0.0075
    default_verticalOffset=0.0075
    default_multiplier=0.05
    default_maxWatermarkHeight=0.20
    default_logoMultiplier=0.04
    default_pointSizeMultiplier=0.020
    default_fontDark="#191919"
    default_fontBright="#E6E6E6"
    default_defaultFill="#272727"
    default_defaultFontColor="#c1c1c1"
    default_offset=0.005
    widthPreset1=960
    heightPreset1=720
    widthPreset2=2000
    heightPreset2=1500
    widthPreset3=3500
    heightPreset3=3500
    widthPreset4=1152
    heightPreset4=768
    widthPreset5=2560
    heightPreset5=1600
    widthPreset6=1200
    heightPreset6=780
    preset1="Digikam"
    preset2="Customers, mid-sized"
    preset3="Instagram"
    preset4="My own website"
    preset5="Tablets and telephones"
    preset6="Pixls.us"

    clear
    printf "%b----------------------------------------------------------------------%b\n" "${red}" "${noColor}"
    printf " %bHere we will determine the standard settings for fotoprep.%b\n" "${darkGray}" "${noColor}"
    printf " %bRun this before using fotoprep or whenever you want to change %b\n" "${darkGray}" "${noColor}"
    printf " %bany of the standard settings. The predifined values will appear%b\n" "${darkGray}" "${noColor}"
    printf " %bin %b(green)%b.%b\n" "${darkGray}" "${green}" "${darkGray}" "${noColor}"
    printf "%b----------------------------------------------------------------------%b\n" "${red}" "${noColor}"
    printf "\n"
    printf " [01/16] %bWatermark File%b\n" "${yellow}" "${noColor}"
    printf " The absolute path to the watermark file.\n"
    printf " For reasons of quality, and because it allows transparency, the\n"
    printf " watermark should be a png file.\n"

    printf " Enter the desired %bpath%b" "${orange}" "${noColor}"
    while read -erp ": " choice; do
        if [[ ! ${choice:0:1} == '/' ]] || [[ ! -f ${choice} ]]; then
            printf " Please enter the full path"
        else
            watermark="$choice"; break
        fi
    done

    clear
    printf " [02/16] %bWatermark Landscape%b\n" "${yellow}" "${noColor}"
    printf " The width of the watermark for an image in landscape orientation.\n"
    printf " A value between 0.01 and 1.\n"
    printf " 1 corresponds to the full width of the image.\n"
    printf " Enter the desired %bwidth%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_landscape" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            landscape=${choice:-$default_landscape}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0.01 && $choice <=1" | bc -l | grep -q 1; then
            landscape="$choice"; break
        else
            printf " Please enter a value between 0.01 and 1 %b(%s)%b" "${green}" "$default_landscape" "${noColor}"
        fi
    done

    clear
    printf " [03/16] %bWatermark Portrait%b\n" "${yellow}" "${noColor}"
    printf " The width of the watermark for an image in portrait orientation.\n"
    printf " A value between 0.01 and 1.\n"
    printf " 1 corresponds to the full width of the image.\n"
    printf " Enter the desired %bwidth%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_portrait" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            portrait=${choice:-$default_portrait}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0.01 && $choice <=1" | bc -l | grep -q 1; then
            portrait="$choice"; break
        else
            printf " Please enter a value between 0.01 and 1 %b(%s)%b" "${green}" "$default_portrait" "${noColor}"
        fi
    done

    clear
    printf " [04/16] %bWatermark Maximum Height%b\n" "${yellow}" "${noColor}"
    printf " The maximum height of the watermark. This is comes into play when an\n"
    printf " image is extremely wide.\n"
    printf " A value between 0.01 and 1.\n"
    printf " 1 corresponds to the full height of the image.\n"
    printf " Enter the desired %bmaximum height%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_maxWatermarkHeight" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            maxWatermarkHeight=${choice:-$default_maxWatermarkHeight}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0.01 && $choice <=1" | bc -l | grep -q 1; then
            maxWatermarkHeight="$choice"; break
        else
            printf " Please enter a value between 0.01 and 1 %b(%s)%b" "${green}" "$default_maxWatermarkHeight" "${noColor}"
        fi
    done

    clear
    printf " [05/16] %bWatermark Position%b\n" "${yellow}" "${noColor}"
    printf " %b(a)%b Center\n" "${cyan}" "${noColor}"
    printf " %b(b)%b East\n" "${cyan}" "${noColor}"
    printf " %b(c)%b Northeast\n" "${cyan}" "${noColor}"
    printf " %b(d)%b North\n" "${cyan}" "${noColor}"
    printf " %b(e)%b Northwest\n" "${cyan}" "${noColor}"
    printf " %b(f)%b Southeast\n" "${cyan}" "${noColor}"
    printf " %b(g)%b South\n" "${cyan}" "${noColor}"
    printf " %b(h)%b Southwest\n" "${cyan}" "${noColor}"
    printf " %b(i)%b West\n" "${cyan}" "${noColor}"
    printf " The position of the watermark on the image.\n"
    printf " Enter the desired %bposition%b %b(f)%b: " "${orange}" "${noColor}" "${green}" "${noColor}"
    while read -r choice; do
        case "$choice" in
            "") position=${choice:-$default_position}; break ;;
            [aA]) position=center; break ;;
            [bB]) position=east; break ;;
            [cC]) position=northeast; break ;;
            [dD]) position=north; break ;;
            [eE]) position=northwest; break ;;
            [fF]) position=southeast; break ;;
            [gG]) position=south; break ;;
            [hH]) position=southwest; break ;;
            [iI]) position=west; break ;;
            *) printf " Please enter a letter from a to i %b(f)%b: " "${green}" "${noColor}" ;;
        esac
    done

    clear
    printf " [06/16] %bWatermark Offset%b\n" "${yellow}" "${noColor}"
    printf " A positive offset always moves the watermark towards the center of\n"
    printf " the image. If the watermark is already centered, the horizontal\n"
    printf " offset will move it to the right and the vertical offset will move\n"
    printf " it down.\n"
    printf " The offset in pixels will be calculated as offset x width or height\n"
    printf " of the image. Values range from -0.9999 to 0.9999.\n"
    printf " Please enter negative numbers with a minus sign; positive numbers\n"
    printf " without a plus sign.\n"
    printf " Enter the desired %bhorizontal offset%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_horizontalOffset" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            horizontalOffset=${choice:-$default_horizontalOffset}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=-0.9999 && $choice <=0.9999" | bc -l | grep -q 1; then
            horizontalOffset="$choice"; break
        else
            printf " Please enter a value between -0.9999 and 0.9999 %b(%s)%b" "${green}" "$default_horizontalOffset" "${noColor}"
        fi
    done

    printf " Enter the desired %bvertikal offset%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_verticalOffset" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            verticalOffset=${choice:-$default_verticalOffset}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=-0.9999 && $choice <=0.9999" | bc -l | grep -q 1; then
            verticalOffset="$choice"; break
        else
            printf " Please enter a value between -0.9999 and 0.9999 %b(%s)%b" "${green}" "$default_verticalOffset" "${noColor}"
        fi
    done

    clear
    printf " [07/16] %bAnnotation Logos Paths%b\n" "${yellow}" "${noColor}"
    printf " Absolute paths to the logos for the annotation bar.\n"
    printf " When the color of the annotation footer is calculated as an average\n"
    printf " of the colors of the image, for very bright images we will need a\n"
    printf " dark logo and vice versa.\n"
    printf " For reasons of quality, and because it allows transparency,\n"
    printf " the logo should be a png file.\n"
    printf " Enter the desired %bpath for the dark logo%b" "${orange}" "${noColor}"
    while read -erp ": " choice; do
        if [[ ! ${choice:0:1} == '/' ]] || [[ ! -f ${choice} ]]; then
            printf " Please enter the full path"
        else
            logoDark="$choice"; break
        fi
    done

    printf " Enter the desired %bpath for the bright logo%b" "${orange}" "${noColor}"
    while read -erp ": " choice; do
        if [[ ! ${choice:0:1} == '/' ]] || [[ ! -f ${choice} ]]; then
            printf " Please enter the full path"
        else
            logoBright="$choice"; break
        fi
    done

    clear
    printf " [08/16] %bAnnotation Font Colors%b\n" "${yellow}" "${noColor}"
    printf " The color of the annotation background is calculated as an average of\n"
    printf " the colors of the image. For very bright images we will need a dark\n"
    printf " font and vice versa, all in hex (#......) notation.\n"
    printf " Enter the desired %bdark font color%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_fontDark" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            fontDark=${choice:-$default_fontDark}; break
        elif [[ ! $choice =~ $colorRegex ]]; then
            printf " %bThis is not a proper hex color code.%b Please try again %b(%s)%b" "${red}" "${noColor}" "${green}" "$default_fontDark" "${noColor}"
        else
            fontDark="$choice"; break
        fi
    done

    printf " Enter the desired %bbright font color%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_fontBright" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            fontBright=${choice:-$default_fontBright}; break
        elif [[ ! $choice =~ $colorRegex ]]; then
            printf " %bThis is not a proper hex color code.%b Please try again %b(%s)%b" "${red}" "${noColor}" "${green}" "$default_fontBright" "${noColor}"
        else
            fontBright="$choice"; break
        fi
    done

    clear
    printf " [09/16] %bAnnotation Background Color, Logo and Font Color%b\n" "${yellow}" "${noColor}"
    printf " Above you chose logos and font colors that will be applied depending\n"
    printf " on the brightness of the annotation background color which was\n"
    printf " calculated as an average of the colors of the image. Here you can\n"
    printf " choose a fixed background color, a fixed logo and a fixed font color.\n"
    printf " Colors are to be entered in hex (#......) notation.\n"
    printf " Enter the desired %bfixed background color%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_defaultFill" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            defaultFill=${choice:-$default_defaultFill}; break
        elif [[ ! $choice =~ $colorRegex ]]; then
            printf " %bThis is not a proper hex color code.%b Please try again %b(%s)%b" "${red}" "${noColor}" "${green}" "$default_defaultFill" "${noColor}"
        else
            defaultFill="$choice"; break
        fi
    done

    printf " Enter the desired %bfixed font color%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_defaultFontColor" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            defaultFontColor=${choice:-$default_defaultFontColor}; break
        elif [[ ! $choice =~ $colorRegex ]]; then
            printf " %bThis is not a proper hex color code.%b Please try again %b(%s)%b" "${red}" "${noColor}" "${green}" "$default_defaultFontColor" "${noColor}"
        else
            defaultFontColor="$choice"; break
        fi
    done

    printf " Enter the desired %bpath for the fixed logo%b" "${orange}" "${noColor}"
    while read -erp ": " choice; do
        if [[ ! ${choice:0:1} == '/' ]] || [[ ! -f ${choice} ]]; then
            printf " Please enter the full path"
        else
            defaultLogo="$choice"; break
        fi
    done

    clear
    printf " [10/16] %bAnnotation Font%b\n" "${yellow}" "${noColor}"
    printf " Which font should appear in the annotations?\n"
    printf " If you choose to see a list of fonts, it will open in the pager\n"
    printf " 'less', to close it type a 'q'.\n"
    printf " Would you like to see the list of fonts on your system %b[y/n]%b(n)%b" "${orange}" "${green}" "${noColor}"; read -erp "? " fontChoice
    if [[ ${fontChoice} = [yY]* ]]; then
        convert -list font | grep "Font:" | less
    fi

    printf " Enter the name of the %bfont %b" "${orange}" "${noColor}"; read -erp ": " textFont

    clear
    printf " [11/16] %bAnnotation Footer Size%b\n" "${yellow}" "${noColor}"
    printf " The percentage of the image height the footer height will be.\n"
    printf " Values range from 0.001 to 0.999.\n"
    printf " Enter the desired %bfooter size%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_multiplier" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            multiplier=${choice:-$default_multiplier}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0.001 && $choice <=0.999" | bc -l | grep -q 1; then
            multiplier=$choice; break
        else
            printf " Please enter a value between 0.001 and 0.999 %b(%s)%b" "${green}" "$default_multiplier" "${noColor}"
        fi
    done

    clear
    printf " [12/16] %bAnnotation Logo Size%b\n" "${yellow}" "${noColor}"
    printf " The percentage of the image height the logo height will be.\n"
    printf " This should not be bigger than the footer size.\n"
    printf " Values range from 0.001 to 0.999.\n"
    printf " Enter the desired %bannotation logo size%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_logoMultiplier" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            logoMultiplier=${choice:-$default_logoMultiplier}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0.001 && $choice <=0.999" | bc -l | grep -q 1; then
            logoMultiplier="$choice"; break
        else
            printf " Please enter a value between 0.001 and 0.999 %b(%s)%b" "${green}" "$default_logoMultiplier" "${noColor}"
        fi
    done

    clear
    printf " [13/16] %bAnnotation Point Size%b\n" "${yellow}" "${noColor}"
    printf " The size of the font in relation to the image size.\n"
    printf " Values range from 0.001 to 0.999.\n"
    printf " Enter the desired %bannotation point size%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_pointSizeMultiplier" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            pointSizeMultiplier=${choice:-$default_pointSizeMultiplier}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0.001 && $choice <=0.999" | bc -l | grep -q 1; then
            pointSizeMultiplier="$choice"; break
        else
            printf " Please enter a value between 0.001 and 0.999 %b(%s)%b" "${green}" "$default_pointSizeMultiplier" "${noColor}"
        fi
    done

    clear
    printf " [14/16] %bAnnotation Offset%b\n" "${yellow}" "${noColor}"
    printf " How far to indent the logo and text relative to the image width.\n"
    printf " Values range from 0.001 to 0.999.\n"
    printf " Enter the desired %bannotation offset%b %b(%s)%b" "${orange}" "${noColor}" "${green}" "$default_offset" "${noColor}"
    while read -erp ": " choice; do
        if [[ -z $choice ]]; then
            offset=${choice:-$default_offset}; break
        elif [[ "$choice" =~ ^[[:digit:].e+-]+$ ]] && echo "$choice>=0 && $choice <=0.999" | bc -l | grep -q 1; then
            offset="$choice"; break
        else
            printf " Please enter a value between 0 and 0.999 %b(%s)%b" "${green}" "$default_offset" "${noColor}"
        fi
    done

    clear
    printf " [15/16] %bDefinition of Presets%b\n" "${yellow}" "${noColor}"
    for j in {1..6}; do
        q="preset$j"
        preset=${!q}
        r="widthPreset$j"
        widthPreset=${!r}
        m="heightPreset$j"
        heightPreset=${!m}

        printf " Enter the desired %bname of Preset %s%b %b(%s)%b" "${orange}" "$j" "${noColor}" "${green}" "$preset" "${noColor}"
        read -erp ": " choice
        if [[ -z $choice ]]; then
            preset[$j]=$preset
        else
            preset[$j]=$choice
        fi

        printf " Enter the desired %bwidth in pixels for Preset %s%b %b(%s)%b" "${orange}" "${j}" "${noColor}" "${green}" "$widthPreset" "${noColor}"
        while read -erp ": " choice; do
            if [[ -z $choice ]]; then
                widthPreset[$j]=$widthPreset; break
            elif [[ "$choice" =~ ^[[:digit:]]+$ ]] && echo "$choice>=1" | bc -l | grep -q 1; then
                widthPreset[$j]=$choice; break
            else
                printf " Please enter a positive integer value for Preset %s" "$j"
            fi
        done

        printf " Enter the desired %bheight in pixels for Preset %s%b %b(%s)%b" "${orange}" "${j}" "${noColor}" "${green}" "$heightPreset" "${noColor}"
        while read -erp ": " choice; do
            if [[ -z $choice ]]; then
                heightPreset[$j]=$heightPreset; break
            elif [[ "$choice" =~ ^[[:digit:]]+$ ]] && echo "$choice>=1" | bc -l | grep -q 1; then
                heightPreset[$j]=$choice; break
            else
                printf " Please enter a positive integer value for Preset %s" "$j"
            fi
        done
    done

    clear
    printf " [16/16] %bCopyright%b\n" "${yellow}" "${noColor}"
    printf " Enter the name of the %bauthor%b" "${orange}" "${noColor}"; read -erp ": " author

    #---------------------------------------------------------------------------
    # Write configuration to $config
    #---------------------------------------------------------------------------
    configuration="    # AUTHOR:   Andreas Betschart.
    # DATE:     23.01.2018.
    # PROGRAM:  fotoprep.
    # VERSION:  1.1.0
    # PURPOSE:  A central place for storing variables used in fotoprep.
    # WARNING:  Do not change this file. It will be overwritten by running the fotoprep setup (fotoprep -s).

    # Full path to your watermark file.
    # Preferably a PNG file, because of the quality and transparency.
    watermark=\"$watermark\"

    # Watermark width for landscape orientation. 1 would be the full image width.
    landscape=$landscape

    # Watermark width for portrait orientation. 1 would be the full image width.
    portrait=$portrait

    # Maximum height of the watermark. For very wide images.
    maxWatermarkHeight=$maxWatermarkHeight

    # Position of the watermark.
    # One of: Center, East, NorthEast, North, NorthWest, SouthEast, South, SouthWest, West.
    position=$position

    # Horizontal offset of the watermark.
    horizontalOffset=$horizontalOffset

    # Vertical offset of the watermark.
    verticalOffset=$verticalOffset

    # Dark logo for annotations.
    logoDark=\"$logoDark\"

    # Bright logo for annotations.
    logoBright=\"$logoBright\"

    # Annotation default background color.
    defaultFill=$defaultFill

    # Annotation default font color.
    defaultFontColor=$defaultFontColor

    # Annotation default logo.
    defaultLogo=\"$defaultLogo\"

    # Footer size of the annotation.
    multiplier=$multiplier

    # Logo size for annotations.
    logoMultiplier=$logoMultiplier

    # Point size for annotations.
    pointSizeMultiplier=$pointSizeMultiplier

    # Horizontal offset for annotations.
    offset=$offset

    # Color of the dark font for annotations.
    fontDark=$fontDark

    # Color of the bright font for annotations.
    fontBright=$fontBright

    # Font for the annotations.
    textFont=\"$textFont\"

    # Name for Preset 1.
    preset[1]=\"${preset[1]}\"

    # Width of images for Preset 1.
    widthPreset1=${widthPreset[1]}

    # Height of images for Preset 1.
    heightPreset1=${heightPreset[1]}

    # Name for Preset 2.
    preset[2]=\"${preset[2]}\"

    # Width of images for Preset 2.
    widthPreset2=${widthPreset[2]}

    # Height of images for Preset 2.
    heightPreset2=${heightPreset[2]}

    # Name for Preset 3.
    preset[3]=\"${preset[3]}\"

    # Width of images for Preset 3.
    widthPreset3=${widthPreset[3]}

    # Height of images for Preset 3.
    heightPreset3=${heightPreset[3]}

    # Name for Preset 4.
    preset[4]=\"${preset[4]}\"

    # Width of images for Preset 4.
    widthPreset4=${widthPreset[4]}

    # Height of images for Preset 4.
    heightPreset4=${heightPreset[4]}

    # Name for Preset 5.
    preset[5]=\"${preset[5]}\"

    # Width of images for Preset 5.
    widthPreset5=${widthPreset[5]}

    # Height of images for Preset 5.
    heightPreset5=${heightPreset[5]}

    # Name for Preset 6.
    preset[6]=\"${preset[6]}\"

    # Width of images for Preset 6.
    widthPreset6=${widthPreset[6]}

    # Height of images for Preset 6.
    heightPreset6=${heightPreset[6]}

    # Author for the image.
    author=\"${author}\""

    echo "$configuration" > "$myPath"/"$config"

    exit 0
fi

#---------------------------------------------------------------------------
# Check if the given parameters are images
#---------------------------------------------------------------------------

for i do # in "$@";
    if file "$i" 2> /dev/null | grep -qE 'image|bitmap'; then
        continue
    else
        printf " %bOne or more of the given arguments are either not an image file or\n" "${red}"
        printf " not a valid option.%b\n" "${noColor}"
        usage
        exit 1
    fi
done

# Check if there is a configuration file
if [[ ! -f "$myPath"/"$config" ]]; then
    printf " There is no configuration file for fotoprep.\n"
    printf " Please run %bfotoprep -s%b first.\n" "${lightPurple}" "${noColor}"
    exit 1
fi

# I don't care if ShellCheck can find the file:
# shellcheck source=/dev/null
source "$myPath"/"$config"
directory=$directory$$

#---------------------------------------------------------------------------
# Here we go.
#---------------------------------------------------------------------------
# Ask some questions in order to know what to do.
clear
printf " %bFormat%b\n" "${yellow}" "${noColor}"
printf " In what format should the images be output? %b[jpg|png|tif]%b(jpg)%b" "${orange}" "${green}" "${noColor}"; read -erp ": " formatChoice
case $formatChoice in
    [Pp]* )
        format=png ;;
    [Tt]* )
        format=tif ;;
        * )
        format=jpg ;;
esac

# Cut the preset name strings after a certain length.
for p in {1..6}; do
    if [[ "${#preset[p]}" -gt 35 ]]; then
        preset[p]="${preset[p]1:0:35}... "
    fi
done

# Print the size menu
printf " %bSize%b\n" "${yellow}" "${noColor}"

for p in {1..6}; do
    w="widthPreset$p"
    h="heightPreset$p"
    widthPreset=( "${!w}" )
    heightPreset=( "${!h}" )

    printf "%b%s%b" "${cyan}" " ($p)" "${noColor}"
    string1=" For ${preset[p]}"
    string2="[${widthPreset[*]} x ${heightPreset[*]}]"
    printf '%s' "$string1"
    printf "%b%*.*s" "${darkGray}" 0 $(( paddingLength - ${#string1} - ${#string2} )) "$padding"
    printf "%b%s\n" "${orange}" "$string2"
done

printf " %b(7)%b Custom dimensions\n" "${cyan}" "${noColor}"
printf " Enter choice%b(7)%b" "${green}" "${noColor}"; read -erp ": " choice

# Ask for the custom size or asign a preset size.
if [[ $choice == 7 ]] || [[ -z $choice ]]; then
    printf " Enter the desired %bwidth%b" "${orange}" "${noColor}"
    while read -erp ": " choice; do
        if [[ "$choice" =~ ^[[:digit:]]+$ ]] && echo "$choice>=1" | bc -l | grep -q 1; then
            targetWidth=$choice; break
        else
            printf " Please enter a positive integer value for the width"
        fi
    done

    printf " Enter the desired %bheight%b" "${orange}" "${noColor}"
    while read -erp ": " choice; do
        if [[ "$choice" =~ ^[[:digit:]]+$ ]] && echo "$choice>=1" | bc -l | grep -q 1; then
            targetHeight=$choice; break
        else
            printf " Please enter a positive integer value for the height"
        fi
    done
else # Asign the preset size.
    w="widthPreset$choice"
    h="heightPreset$choice"
    targetWidth=${!w}
    targetHeight=${!h}
fi

printf " %bWatermark or Annotation%b\n" "${yellow}" "${noColor}"
printf " Should a watermark, annotation or nothing be added? %b[w|a|n]%b(n)%b" "${orange}" "${green}" "${noColor}"; read -erp ": " watermarkChoice

case $watermarkChoice in
    [Ww]* ) # Watermark.
        watermarkChoice=w
        if [[ ! -f "${watermark}" ]]; then
            printf " %bCannot find the watermark file.%b Did you move it?\n" "${red}" "${noColor}"
            exit 66
        fi
        ;;
    [Aa]* ) # Annotate.
        watermarkChoice=a
        if [[ ! -f "${logoDark}" ]] || [[ ! -f "${logoBright}" ]]; then
            printf " %bAt least one of the logos couldn't be found.%b Did you move them?\n" "${red}" "${noColor}"
            exit 66
        fi

        printf " %bAnnotaion Background Color%b\n" "${yellow}" "${noColor}"
        printf " Use the average of the image or the predefined color? %b[a|p]%b(a)%b" "${orange}" "${green}" "${noColor}"; read -erp ": " backgroundChoice

        printf " %bDescription%b\n" "${yellow}" "${noColor}"
        printf " Add the description from the metadata of the image?%b...%b[y|n]%b(n)%b" "${darkGray}" "${orange}" "${green}" "${noColor}"; read -erp ": " descriptionChoice
        ;;
    * ) # Nothing.
        watermarkChoice=n
        ;;
esac

printf " %bSharpening%b\n" "${yellow}" "${noColor}"
printf " %b(0)%b None\n" "${cyan}" "${noColor}"
printf " %b(1)%b Very little\n" "${cyan}" "${noColor}"
printf " %b(2)%b A bit more\n" "${cyan}" "${noColor}"
printf " %b(3)%b Default\n" "${cyan}" "${noColor}"
printf " %b(4)%b Strong\n" "${cyan}" "${noColor}"
printf " %b(5)%b Stronger\n" "${cyan}" "${noColor}"
printf " %b(6)%b Very Strong\n" "${cyan}" "${noColor}"
printf " %b(7)%b Insane\n" "${cyan}" "${noColor}"
printf " Enter choice%b(3)%b" "${green}" "${noColor}"; read -erp ": " sharpeningChoice

case $sharpeningChoice in
    0 ) # None
        sharpeningRadius=0
        sharpeningAmount=0 ;;
    1 ) # Very little
        sharpeningRadius=0.5 ;;
    2 ) # A bit more
        sharpeningRadius=1.0 ;;
    4 ) # Strong
        sharpeningRadius=2.5 ;;
    5 ) # Stronger
        sharpeningRadius=3.0 ;;
    6 ) # Very Strong
        sharpeningRadius=4.5 ;;
    7 ) # Insane
        sharpeningRadius=6.0 ;;
    * ) # Default
        sharpeningRadius=1.5 ;;
esac

# NOTE:     Sharpening is done following the advice from:
#           https://redskiesatnight.com/2005/04/06/sharpening-using-image-magick/
#           if radius < 1, then sigma = radius
#           else sigma = sqrt(radius)

if (( $(echo "$sharpeningRadius < 1" | bc -l) )); then
    sharpeningSigma=$sharpeningRadius
else
    sharpeningSigma=$(echo "scale=2; sqrt($sharpeningRadius)" | bc -l)
fi

# Here we create a directory, move all the images there and go there.
if [[ ! -d "./$directory" ]]; then
    mkdir "./$directory"
fi

mkdir "$directory"/"$workingDirectory"

# Copy the files to the $directory. Add some safety checks.
num=1
for i do # in "$@";
    extension="${i##*.}"           # get the extension
    basename="$(basename "$i")"    # get the filename without path
    filename="${basename%.*}"      # get the filename without extension
    mapfile -t lsArray < <(ls "${directory}") # put ls $directory into an lsArray

    if [[ ! "${lsArray[*]}" =~ ${filename} ]]; then
        cp "$i" "$directory"

        # Also copy the pp3 sidecar files for raw files
        if [[ -f "$i".pp3 ]]; then
            cp "$i".pp3 "$directory"
        fi
    else

        # Copy the files but add a string and a running number before
        # the extension, in order to avoid problems if we have files
        # with the same name but different extension (eg.: aaa.xcf and aaa.nef).
        cp "$i" "$directory"/"${filename}"_ftprp${workingDirectory}_${num}."${extension}"

        # Also copy the pp3 sidecar files for raw files
        if [[ -f "$i".pp3 ]]; then
            cp "$i".pp3 "$directory"/"${filename}"_ftprp${workingDirectory}_${num}."${extension}.pp3"
        fi
        ((num++))
    fi
done

cd "$directory" || { echo "Changing into $directory failed"; exit 1; }

#---------------------------------------------------------------------------
# Here we start working on the images.
#---------------------------------------------------------------------------
printf " Converting the images%b..........................................%b  " "${darkGray}" "${noColor}"

for i in *.*; do
    # Ignore pp3 files.
    if [[ "${i: -4}" == ".pp3" ]]; then
        continue
    fi

    # If it is a tif, only move it to the workingDirectory.
    if [[ "${i: -4}" == ".tif" ]]; then
        mv "$i" "$workingDirectory"

        # If it is an xcf, convert and move it to the workingDirectory.
    elif [[ "${i: -4}" == ".xcf" ]]; then
        {
            gimp -n -i -b - <<EOF
            (let* ( (file's (cadr (file-glob "*.xcf" 1))) (filename "") (image 0) (layer 0) )
            (while (pair? file's)
            (set! image (car (gimp-file-load RUN-NONINTERACTIVE (car file's) (car file's))))
            (set! layer (car (gimp-image-merge-visible-layers image CLIP-TO-IMAGE)))
            (set! filename (string-append (substring (car file's) 0 (- (string-length (car file's)) 4)) ".tif"))
            (gimp-file-save RUN-NONINTERACTIVE image layer filename filename)
            (gimp-image-delete image)
            (set! file's (cdr file's))
                    )
                    (gimp-quit 0)
                    )
EOF
        } &> /dev/null
# The EOF cannot be indented, otherwise it will not work

        # Delete the xcf file.
        rm "$i" 2>/dev/null

        # Change the extension for i in order to process the new file, not the original.
        s="$i"; s=${s##*/}; i=${s%.*}.tif
        mv "$i" "$workingDirectory" 2>/dev/null

        # Use RawTherapee to convert RAW files.
    elif [[ " ${rawFormats[*]} " == *"${i: -4}"* ]]; then
        rawtherapee-cli -S -t -c "$i" &>/dev/null

        # Delete the RAW file and the pp3.
        rm "$i" 2>/dev/null
        rm "$i".pp3 2>/dev/null

        # Change the extension for i in order to process the new file, not the original.
        s="$i"; s=${s##*/}; i=${s%.*}.tif
        mv "$i" "$workingDirectory" 2>/dev/null
    else
        mogrify -path "$workingDirectory" -auto-orient -compress none -format tif "$i" 2>/dev/null

        # Mogrifying to tif deletes the exift tags. Copy the tags.
        exiftool -m -q -q -TagsFromFile "$i" -x Orientation "$workingDirectory"/"${i%.*}".tif

        # Remove the original file and the _original file.
        rm "$i" 2>/dev/null
        rm "$workingDirectory"/"${i%.*}".tif_original 2>/dev/null
    fi
done & spinner

#---------------------------------------------------------------------------
# Watermarking and annotating.
#---------------------------------------------------------------------------
cd "$workingDirectory" || { echo "Changing into $workingDirectory failed"; exit 1; }

printf " Resizing, adding the watermark or annotation%b...................%b  " "${darkGray}" "${noColor}"
for i in *.tif; do
    # Nothing. ####################################
    if [[ "$watermarkChoice" == "n" ]]; then
        convert -quiet "$i" -colorspace RGB -resize "$targetWidth"x"$targetHeight"\> -colorspace sRGB -unsharp "${sharpeningRadius}"x"${sharpeningSigma}"+"${sharpeningAmount}"+"${sharpeningThreshold}" -quality 99% "${i%.*}"."$format"

        if [[ "$format" == "tif" ]]; then
            continue
        else
            rm "$i" 2>/dev/null
        fi

    # Annotate. ####################################
    elif [[ "$watermarkChoice" == "a" ]]; then
        # Extract height and width of the image.
        width=$(identify -quiet -format "%w" "$i")
        height=$(identify -quiet -format "%h" "$i")

        # Calculate footer height (footerHeight)
        # Calculate logo height (LH).
        # Calculate horizontal logo offset (LO).
        # Calculate horizontal comment offset (HO).
        # Calculate the vertical comment offset (VCO).
        # ImageMagick does not center the text vertically properly.
        # Calculate the pointsize (PS).
        if (( $(echo "$height <= $targetHeight" | bc -l) )); then
            footerHeight="$(echo "$height*$multiplier" | bc)"
            LH="$(echo "$height*$logoMultiplier" | bc)"
            HO="$(echo "$targetWidth*$offset" | bc)"
            VCO="$(echo "$height*0.0005" | bc -l)"
            LO="$(echo "$width*$offset*0.75" | bc)"
            PS="$(echo "$height*$pointSizeMultiplier" | bc)"
        else
            footerHeight="$(echo "$targetHeight*$multiplier" | bc)"
            LH="$(echo "$targetHeight*$logoMultiplier" | bc)"
            HO="$(echo "$targetWidth*$offset" | bc)"
            VCO="$(echo "$targetHeight*0.001" | bc -l)"
            LO="$(echo "$targetWidth*$offset*0.75" | bc)"
            PS="$(echo "$targetHeight*$pointSizeMultiplier" | bc)"
        fi

        # Fill $description if comment/title is desired.
        case $descriptionChoice in
            [Yy]* )
                # Extract the values of the title and usercomment tags.
                imageDescription=$(exiftool -s -s -s -m -q -q -ImageDescription "$i")
                description=$(exiftool -s -s -s -m -q -q -Description "$i")
                userComment=$(exiftool -s -s -s -m -q -q -UserComment "$i")

                if [[  -n "$imageDescription" ]]; then
                    descriptionTag="$imageDescription"
                elif [[ -n "$description" ]]; then
                    descriptionTag="$description"
                else
                    descriptionTag="$userComment"
                fi
                ;;
        esac

        # Which fill?
        case $backgroundChoice in
            [pP]*)
                fill=$defaultFill
                textColor=$defaultFontColor
                logo="$defaultLogo"
                ;;
            *)  # Extract the average color of the image to use as background fill.
                averagecolor=$(convert "$i" -quiet -scale 1x1\! txt:-|grep -E -o '#\w+')
                fill=$averagecolor

                # Extract the average brightness to define the text color.
                layers="$(magick "$i" -quiet -format "%N" info: 2>/dev/null)"
                if [[ $layers -gt 1 ]]; then
                    bright=$(convert ""$i"[0]" -quiet -colorspace LAB -channel r -separate +channel -format "%[mean]\n" info: 2>/dev/null)
                else
                    bright=$(convert "$i" -quiet -colorspace LAB -channel r -separate +channel -format "%[mean]\n" info: 2>/dev/null)
                fi
                bright="$(echo "$bright/65535" | bc -l)"
                # If the brightness is more than 0.65, make the text and logo dark.
                if (( $(echo "$bright > 0.70" | bc -l) )); then
                    logo="$logoDark"
                    textColor="$fontDark"
                else
                    logo="$logoBright"
                    textColor="$fontBright"
                fi
                ;;
        esac

        # Get the year for the copyright notice.
        modifyDate=$(exiftool -s -s -s -m -q -q -ModifyDate "$i" 2>/dev/null)

        if [[ -z "$modifyDate" ]]; then
            theYear=${theDate:0:4}
        else
            theYear=$(exiftool -s -s -s -m -q -q -ModifyDate "$i" 2>/dev/null)
            theYear=${theYear:0:4}
        fi

        # Calculate horizontal copyright offset (CO)
        logoWidth=$(identify -quiet -format "%w" "$logo" 2>/dev/null)
        logoHeight=$(identify -quiet -format "%h" "$logo" 2>/dev/null)
        ratio="$(echo "$logoHeight/$LH" | bc -l)"
        LW="$(echo "$logoWidth/$ratio" | bc)"
        CO="$(echo "($LO*2)+($LW*1.05)" | bc)"

        # Since the footer will be added to the image,
        # reduce the targetHeight by the footerHeight.
        targetHeight="$(echo "$targetHeight-$footerHeight" | bc)"

        # Do the magick on the image.
        magick "$i" -colorspace RGB -resize "${targetWidth}"x"${targetHeight}"\> -colorspace sRGB -unsharp "${sharpeningRadius}"x"${sharpeningSigma}"+"${sharpeningAmount}"+"${sharpeningThreshold}" \
            \( +clone \
            -quiet \
            -fill "$fill" \
            -draw 'color 0,0 reset' \
            -resize x"$footerHeight"! \
            -fill "$textColor" \
            -font "$textFont" \
            -pointsize "$PS" \
            -gravity east \
            -annotate +"$HO"+"$VCO" "$descriptionTag" \
            -gravity west \
            -annotate +"$CO"+"$VCO" "© $theYear $author" \
            -gravity west \
            \( "$logo" -resize x"$LH" \) \
            -geometry +"$LO"+0 -composite \) \
            -quality 99% \
            -append "${i%.*}"."$format" 2>/dev/null

        # Reset the targetHeight.
        targetHeight="$(echo "$targetHeight+$footerHeight" | bc)"

        if [[ "$format" == "tif" ]]; then
            continue
        else
            rm "$i" 2>/dev/null
        fi

    # Watermark. ####################################
    elif [[ "$watermarkChoice" == "w" ]]; then

        width=$(identify -quiet -format "%w" "$i" 2>/dev/null)
        height=$(identify -quiet -format "%h" "$i" 2>/dev/null)

        if [[ "$width" -gt "$height" ]]; then
            multiplier=$landscape # Width of the watermark for images in landscape orientation.
        else
            multiplier=$portrait # Width of the watermark for images in portrait orientation.
        fi

        # Get the new width of the image after resizing in order to calculate the width of the watermark.
        # Get the new height in oder to place the watermark properly.
        newWidth=$(convert "$i" -quiet -resize "${targetWidth}"x"${targetHeight}"\> -format "%[w]" info: 2> /dev/null)
        newHeight=$(convert "$i" -quiet -resize "${targetWidth}"x"${targetHeight}"\> -format "%[h]" info: 2> /dev/null)

        # Calculate watermark width (WW)
        WW="$(echo "$newWidth*$multiplier" | bc -l)"

        # Calculate watermark height (WH)
        WH=$(convert "$watermark" -quiet -resize "${WW}" -format "%[h]" info: 2> /dev/null)

        # If the watermark is higher than $maxWatermarkHeight,
        # the watermark height is $maxWatermarkHeight.
        if (( $(echo "$WH > ($newHeight*$maxWatermarkHeight)" | bc -l) )); then
            WH="$(echo "$newHeight"*"$maxWatermarkHeight" | bc -l) "
        fi

        # Calculate watermark horizontal offset (HO) and vertical offset (VO).
        HO="$(echo "$newWidth*$horizontalOffset" | bc -l)"
        VO="$(echo "$newHeight*$verticalOffset" | bc -l)"

        # If HO or VO are smaller than 1, make them 1.
        if (( $(echo "$HO < 1" | bc -l) )); then HO=1; fi
        if (( $(echo "$VO < 1" | bc -l) )); then VO=1; fi

        # Resize the image.
        convert -quiet "$i" -colorspace RGB -resize "$targetWidth"x"$targetHeight"\> -colorspace sRGB -unsharp "${sharpeningRadius}"x"${sharpeningSigma}"+"${sharpeningAmount}"+"${sharpeningThreshold}" "$i" 2> /dev/null

        # Add the watermark.
        composite -quiet -gravity "$position" -geometry +"$HO"+"$VO" \( "$watermark" -resize "${WW}"x"${WH}" \) -quality 99% "$i" "${i%.*}"."$format" 2>/dev/null

        if [[ "$format" == "tif" ]]; then
            continue
        else
            rm "$i" 2>/dev/null
        fi
    fi
done & spinner

#---------------------------------------------------------------------------
# Editing the metadata
#---------------------------------------------------------------------------
printf " Adding the copyright to the metadata%b...........................%b  " "${darkGray}" "${noColor}"
for i in *.*; do
    # Get the year for the copyright notice.
    # PNG does not have the DateTimeOriginal tag.
    if [[ "$format" == "png" ]]; then
        modifyDate=$(exiftool -s -s -s -m -q -q -tiffDateTime "$i")
    else
        modifyDate=$(exiftool -s -s -s -m -q -q -DateTimeOriginal "$i")
    fi

    # If the year is empty, use the current year.
    if [[ -z "$modifyDate" ]]; then
        theYear=${theDate:0:4}
    else
        if [[ "$format" == "png" ]]; then
            theYear=$(exiftool -s -s -s -m -q -q -tiffDateTime "$i")
        else
            theYear=$(exiftool -s -s -s -m -q -q -DateTimeOriginal "$i")
        fi
        # If the year is empty, use the current year.
        theYear=${theYear:0:4}
    fi

    exiftool -all= \
        -P \
        -m \
        -q \
        -q \
        -overwrite_original \
        -tagsfromfile @ \
        -ICC_Profile \
        -EXIF:ColorSpace= \
        -CommonIFD0= \
        -UniqueCameraModel= \
        -ProcessingSoftware= \
        -DocumentName= \
        -LocalizedCameraModel= \
        -CameraSerialNumber= \
        -PrimaryChromaticities= \
        -WhitePoint= \
        -EXIF:Artist="$author" \
        -EXIF:Copyright="Copyright © $theYear $author. All rights reserved." \
        -EXIF:ModifyDate \
        -XMP:Creator="$author" \
        -XMP:Rights="Copyright © $theYear $author. All rights reserved." \
        -XMP:Artist="$author" \
        -XMP:Copyright="Copyright © $theYear $author. All rights reserved." \
        -IPTC:By-line="$author" \
        -IPTC:CopyrightNotice="Copyright (C) $theYear $author. All rights reserved." \
        "$i" -o ..

done & spinner

#---------------------------------------------------------------------------
# Cleaning up
#---------------------------------------------------------------------------
cd ..
rmdir "$workingDirectory"
rm ./*.pp3 2>/dev/null
cd ..

printf " Ready, your images can be found under %s/%b%s%b.\n" "$PWD" "${lightPurple}" "${directory}" "${noColor}"
